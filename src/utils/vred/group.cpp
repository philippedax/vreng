#include <fstream>

#include "vred.hpp"
#include "group.hpp"
#include "vect.hpp"
#include "input.hpp"


Group::Group(const char* _name, const int _renderStyle, const Color& _color):
  Solid(_name, Vect::null, Vect::null, Vect::unit, _renderStyle, _color), 
  group(new Solid*[GROUP_CHUNK_SIZE]), card(0) 
{
  myBoundingBox.set(Vect::null,0,0,0,0);
  myBoundingSphere.set(Vect::null,0);
}

Group::~Group()
{
  if (group != NULL) {
    for (int i=0; i < card; ++i) if (group[i]) delete group[i];
    delete[] group;
  }
}

void Group::render()
{
  glPushMatrix();
  glMatrixMode(GL_MODELVIEW);
  glMultMatrixd(modelView);
  for (int i=0; i < card; ++i)
    group[i]->render();
  glPopMatrix();
}

void Group::add(Solid* const solid)
{
  // check if the solid isn't already in the group
  for (int i=0; i < card; ++i)
    if (group[i] == solid) return;

  // put the solid into the relative ref
  solid->changeRef(modelView.invert());

  // if necessary, augment the size of the group data holder
  if ((card % GROUP_CHUNK_SIZE == 0) && (card != 0)) {
    Solid** _group = new Solid*[card + GROUP_CHUNK_SIZE];
    for (int k=0; k < card; ++k) _group[k] = group[k];
    if (group) delete[] group;
    group = _group;
  }

  // and finally add the solid to the group
  group[card] = solid;
  if (&getRoot() != this)
    getRoot().remove(solid);
  solid->setFather(this);
  ++card;

  updateBB(0);
}

void Group::remove(Solid* const solid) 
{
  for (int i=0; i < card; ++i)
    if (group[i] == solid) {
      // remove the solid
      group[i] = group[card - 1];
      --card;

      // if necessary, reduce the size of the group data holder
      if ((card % GROUP_CHUNK_SIZE == 0) && (card != GROUP_CHUNK_SIZE) && (card != 0)) {
	Solid** _group = new Solid*[card];
	for (int j=0; j < card; ++j)
	  _group[j] = group[j];
	delete[] group;
	group = _group;
      }

      // put the solid back into the root group
      if (&getRoot() != this) {
	solid->setAbsoluteModelView();
	getRoot().add(solid);
	//solid->updateBB();
      }
    }
  updateBB(0);
}

void Group::explode()
{
  while (card > 0) {
    remove(group[0]);
  }
}

void Group::setStyle(const int _renderStyle)
{
  renderStyle = _renderStyle;
  for (int i=0; i < card; ++i)
    group[i]->setStyle(_renderStyle);
}

void Group::setColor(const Color& _color)
{
  color = _color;
  for (int i=0; i < card; ++i)
    group[i]->setColor(_color);
}

void Group::printFile(const char *file) const
{
  ofstream out(file, ios::out);
  out << "<!-- File generated by vred -->\n\n" ;
  out << "<vre version=\"7.2\">\n<meta>\n<meta name=\"filename\" content=\"" << file << "\"/>\n</meta>\n<scene>\n\n" ;
  out << *this;
  out << "</scene>\n</vre>\n" ;
}

int Group::loadFile(const char *file)
{
  FILE *fp = fopen(file,"r");
  if (fp == NULL) { return (255); }
  int res = loadFile(fp);
  fclose(fp);
  return res;
}

int Group::loadFile(FILE *fp)
{
  return fileToGroup(fp, this);
}

int Group::collide(Solid& moving) const
{
  if (!getBoundingSphere().collide(moving.getBoundingSphere())) return 0;
  if (!getBoundingBox().collide(moving.getBoundingBox())) return 0; 

  for (int i=0; i < getCard() ; i++) {
    Solid* other=group[i];
    if (other==&moving) continue;
    if (!other->getBoundingSphere().collide(moving.getBoundingSphere())) continue;
    if (!other->getBoundingBox().collide(moving.getBoundingBox())) continue;
    return 1;
  }
  return 0;
}
